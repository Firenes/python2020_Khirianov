Имя (переменная) хранит ссылку на объект.

Объекты существуют вне зависимости от имён.

И тип (int, float, bool...) принадлежат объекту, а не имени.

И по сути есть изменяемые и неизменяемые объекты.

x = 2

= –– по факту называется связыванием, так как связывается с объектом по ссылке (а не присваивание)

Объекты в Python создаются во время вычисления.

К примеру, x = 2 + 3. В памяти создаются два отдельных объекта –– 2 и 3. Затем над ними происходит операция сложения "+" и создаётся новый объект 5, который связывается с именем x.
А объекты 2 и 3 уничтожаются.

Если введём y и y = x, то y и x будут указывать на один и тот же объект.

Объекты int являются неизменяемыми. Поэтому при прибавлении к объекту, к примеру, единицу, то происходит операция, которая описана выше (создаётся новый объект)



Кортежи (type –– tuple):
Кортежи неизменяемые (если имеют адрес объекта, то объект можно будет изменить)

x,y,z = 1,2,3

Кортежи являются удобным средством, чтобы не прописывать алгоритм с присваиванием значений через третью переменную

temp = x
x = y
y = temp

Если через 2 переменные:

t1,t2 = y,x
x,y = t1,t2

Или просто:

x,y = y,x 


Использование кортежа:

T = 1,2,3,4,5
a,b,c,d,e = T

Чтобы присвоить конкретный объект из кортежа, указав индекс объекта:

x = T[0]

Если нужны первые 2 объекта из кортежа, то можно сделать так:
В данном случае первые 2 элемента будут в a и b, а остальное будет в rest

a,b,*rest = T

(a = 0, b = 1, rest = 3,4,5)

При распечатывании кортежа, внутренность оного распечатается как (1,2,3,4,5)
Если хочется, чтобы значения шли через пробел, то можно добавить * перед именем кортежа –– *T –– 1 2 3 4 5.

* –– символ распаковки кортежа

print() также поддерживает разделители –– sep="", где в кавычкам может указать любой набор символов и end="", где в конце распечатки также указать любой набор символов.

print(*T, sep=",", end="!\n")	# 1,2,3,4,5!


Кортеж –– объект, который содержит в себе ссылки, поэтому в него можно положить что угодно.


В Python есть аннотация типов, т.е. в параметрах функций можно указывать какого типа объект можно передавать.

def –– обозначение функций (define)

def hello_n(name: str, n: int):
    print(name, "привет")

В параметры может не передавать отдельно str и int, а можно передать сразу кортеж со str и c int

hello_n('Никита', 3)

nik = 'Никита', 3
hello_n(*nik)



range()
range() –– это итерируемый объект, также является генератором арифметической прогрессии, которая возвращает, собственно, арифметическую прогрессию

range() принимает в себя три int параметра –– start, stop, step

range() имеет тип range.

A = range(1, 6) # если шаг 1, то его можно не указывать

print(*A) # 1 2 3 4 5
print(A) # range(1, 10)

range можно использовать как доступ к элементам итерируемого объекта, т.е.

for i in A:
    print(i)




A = [1, 2, 3] –– list, список

Отличие списка от кортежа в том, что list изменяемый. Он содержит в себе 3 ссылки, в каждую из которых можно положить что угодно. (по сути является последовательностью ссылок на объекты)

В список, как и в кортеж можно класть разнотиповые объекты, в отличии от массива. В массиве объекты лежат друг за другом в памяти.

Особенность списка в том, что в него можно положить кортежи:

А = [(1, 2), (10, 10), (3, 30)]

В список можно добавлять элементы, но в конец списка:

A.append((4, 40))

Чтобы узнать длину A, можно использовать len(A)

for i in range(len(A)):
    angle, length = A[i]
    turtle.forward(length)

Можно упростить:

for T in A:
    angle, length = T
    turtle.forward(length)

Или так, но при условии, что в итерируемом объекте известно что лежит:

for angle, length in A:
    turtle.forward(length)


Для знания индекса элемента можно использовать enumerate():

for i, T in enumerate(A):
    ...




Множества (set) и словари (dict)

Элементы в set и dict неупорядочены.

S = {'Moscow', 'Dolgoprudny', 'Piter'} –– множество

Во множество можно добавить объект с помощью

s.add('Rostov')

if 'Riga' in S:
    print(...)

for el in S:
    print(el)



D = {'Moscow': 1, 'Dolgoprudny': 2, 'Piter': 3} –– словарь. где хранятся ключ и значения

Добавление:

D['Rostov'] = 4

for key in D:
    print(key, D[key])